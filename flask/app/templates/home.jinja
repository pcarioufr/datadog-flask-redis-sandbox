<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Public Sans font import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Public+Sans:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- DEBUG INFO -->
    <!-- env={{dd_env}} -->
    <!-- version={{dd_version}} -->
    <!-- site={{dd_site}} -->
    <!-- token={{clientToken}} -->
    <!-- user_id={{user_id}} -->
    <!-- user_email={{user_email}} -->
    <!-- is_anonymous={{is_anonymous}} -->


<!-- See https://docs.datadoghq.com/logs/log_collection/javascript -->
<!--     https://docs.datadoghq.com/real_user_monitoring/browser  -->
<script 
    type="text/javascript" 
    src="https://www.datadoghq-browser-agent.com/datadog-logs-v4.js">
</script>

<script
    src="https://www.datadoghq-browser-agent.com/datadog-rum-v4.js"
    type="text/javascript">
</script>

<script>

        window.DD_LOGS &&
        DD_LOGS.init({
            site: '{{dd_site}}',
            clientToken: '{{clientToken}}',
            env: '{{dd_env}}',
            version: '{{dd_version}}',
            service: 'browser',
            forwardErrorsToLogs: true,
            sampleRate: 100,
            forwardConsoleLogs: 'all'
        })

        window.DD_RUM && window.DD_RUM.init({
            site: '{{dd_site}}',
            clientToken: '{{clientToken}}',
            env: '{{dd_env}}',
            version: '{{dd_version}}',
            service: 'browser',
            applicationId: '{{applicationId}}',
            sampleRate: 100,
            sessionReplaySampleRate: 100,
            trackInteractions: true,
            trackResources: true,
            trackLongTasks: true,
            defaultPrivacyLevel: 'mask-user-input',
            allowedTracingUrls: [ _ => { return true } ] // https://docs.datadoghq.com/real_user_monitoring/connect_rum_and_traces/?tab=browserrum
        });

        window.DD_RUM &&
        window.DD_RUM.startSessionReplayRecording() ;

        window.DD_LOGS && DD_LOGS.setGlobalContextProperty('team', "sandbox")

        window.DD_RUM && window.DD_RUM.setUser({ 
            id: '{{user_id}}', 
            email: '{{user_email}}', 
            anonymous: '{{is_anonymous}}'
        })
        // window.DD_RUM && window.DD_RUM.addRumGlobalContext('domain', '{{domain}}');

    </script>


    <meta charset="utf-8">
    <title>Chat Sandbox</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='home.css') }}" />


</head>

<body>
    <div class="user-info">
        <span class="user-id">{{user_id}}</span>
        <span class="user-email">{{user_email}}</span>
    </div>
    
    <div class="chat-thread">
        <div class="messages" id="chat-messages"></div>

    </div>
    
    <div class="chat-controls">
        <div class="message-input">
            <textarea 
                id="chat-input" 
                placeholder="Type your message here..."
                onkeydown="if(event.keyCode === 13 && !event.shiftKey) { event.preventDefault(); sendMessage(); }"
            ></textarea>
            <button onclick="sendMessage()" id="send-button">Send</button>
        </div>
        <div class="chat-actions">
            <button id="clear-chat-button" class="clear-chat-btn">Clear Chat History</button>
        </div>
    </div>

    <script>
        const messageInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const messagesContainer = document.getElementById('chat-messages');
        
        // Token buffer and rendering mechanism
        class TokenBuffer {
            constructor(minChunkSize = 50, maxDelay = 50) {
                this.buffer = '';
                this.minChunkSize = minChunkSize;  // minimum characters before rendering
                this.maxDelay = maxDelay;          // max milliseconds to wait before rendering
                this.timeout = null;
                this.lastRenderTime = Date.now();
                this.startTime = Date.now();       // Track when streaming began
                this.contentDiv = null;            // Div for actual content
                this.loadingDots = null;           // Loading dots element
            }
            
            // Smoothly scroll to the bottom of chat
            smoothScrollToBottom() {
                const chatThread = document.querySelector('.chat-thread');
                const startTime = Date.now();
                const startScroll = chatThread.scrollTop;
                const targetScroll = chatThread.scrollHeight - chatThread.offsetHeight;
                
                console.log(`[Scroll] Token render at ${Date.now() - this.startTime}ms`);
                console.log(`[Scroll] Start position: ${startScroll}px`);
                console.log(`[Scroll] Target position: ${targetScroll}px`);
                
                chatThread.style.scrollBehavior = 'smooth';
                chatThread.scrollTop = targetScroll;
                
                // Reset scroll behavior after animation
                setTimeout(() => {
                    chatThread.style.scrollBehavior = 'auto';
                }, 300); // Shorter timeout since we're doing this frequently
            }
            
            // Force render the current buffer
            flush() {
                if (this.buffer) {
                    const now = Date.now();
                    const elapsedMs = now - this.startTime;
                    const timeSinceLastRender = now - this.lastRenderTime;
                    console.log(
                        `[${elapsedMs}ms] Rendering chunk after ${timeSinceLastRender}ms ` +
                        `(${this.buffer.length} chars):`, 
                        this.buffer
                    );
                    const span = document.createElement('span');
                    span.textContent = this.buffer;
                    span.className = 'token';
                    this.contentDiv.appendChild(span);
                    this.smoothScrollToBottom();  // Scroll after adding content
                    this.buffer = '';
                    this.lastRenderTime = now;
                }
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
            }
            
            // Add text to buffer and schedule rendering
            append(text) {
                // On first append, ensure we have content div
                if (!this.contentDiv) {
                    // Create content div if it doesn't exist
                    this.contentDiv = document.createElement('div');
                    this.contentDiv.className = 'message-content';
                    this.messageDiv.appendChild(this.contentDiv);
                    
                    // Move loading dots after content div
                    if (this.loadingDots) {
                        this.messageDiv.appendChild(this.loadingDots);
                    }
                }
                
                this.buffer += text;
                
                // If buffer is large enough, render immediately
                if (this.buffer.length >= this.minChunkSize) {
                    this.flush();
                    return;
                }
                
                // Otherwise, schedule a delayed render
                if (!this.timeout) {
                    this.timeout = setTimeout(() => this.flush(), this.maxDelay);
                }
            }
            
            // Clear the buffer and any pending renders
            clear() {
                this.buffer = '';
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
            }

            // Initialize a new message div
            startNewMessage() {
                this.messageDiv = document.createElement('div');
                this.messageDiv.className = 'message assistant-message';
                this.messageDiv.style.whiteSpace = 'pre-wrap';
                
                // Add loading indicator
                this.loadingDots = document.createElement('div');
                this.loadingDots.className = 'loading-dots';
                this.loadingDots.innerHTML = '<span></span><span></span><span></span>';
                this.messageDiv.appendChild(this.loadingDots);
                
                messagesContainer.appendChild(this.messageDiv);
                this.startTime = Date.now();
                this.lastRenderTime = Date.now();
                console.log('[0ms] Starting new message rendering');
                
                // Initial scroll for the loading indicator
                this.smoothScrollToBottom();
            }
            
            // Complete the message and remove loading dots
            complete() {
                this.flush(); // Render any remaining buffered content
                if (this.loadingDots) {
                    this.loadingDots.remove();
                    this.loadingDots = null;
                }
                this.smoothScrollToBottom();
            }
        }

        // Load chat history when page loads
        async function loadChatHistory() {
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        initial_load: true
                    })
                });

                const data = await response.json();
                
                if (data.history && data.history.length > 0) {
                    // Display each message from history
                    data.history.forEach(msg => {
                        addMessage(msg.content, msg.role === 'user');
                    });
                }
            } catch (error) {
                console.error('Error loading chat history:', error);
                addMessage('Hello! How can I help you today?', false);
            }

            // Ensure DOM is updated before final scroll
            setTimeout(() => {
                const chatThread = document.querySelector('.chat-thread');
                const startTime = Date.now();
                const startScroll = chatThread.scrollTop;
                const targetScroll = chatThread.scrollHeight - chatThread.offsetHeight;
                
                console.log('[Scroll] History loaded, starting final scroll');
                console.log(`[Scroll] Container height: ${chatThread.offsetHeight}px`);
                console.log(`[Scroll] Scroll height: ${chatThread.scrollHeight}px`);
                console.log(`[Scroll] Start position: ${startScroll}px`);
                console.log(`[Scroll] Target position: ${targetScroll}px`);
                
                // Enable smooth scrolling and scroll to bottom
                chatThread.style.scrollBehavior = 'smooth';
                chatThread.scrollTop = targetScroll;
                
                // Log completion and reset scroll behavior
                setTimeout(() => {
                    console.log(`[Scroll] Final position: ${chatThread.scrollTop}px`);
                    console.log(`[Scroll] History scroll completed after ${Date.now() - startTime}ms`);
                    chatThread.style.scrollBehavior = 'auto';
                }, 1000); // Wait for animation to complete
            }, 100);
        }

        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
            messageDiv.style.whiteSpace = 'pre-wrap';
            messageDiv.innerText = content;
            messagesContainer.appendChild(messageDiv);
            
            // Scroll with animation
            const chatThread = document.querySelector('.chat-thread');
            const startTime = Date.now();
            const startScroll = chatThread.scrollTop;
            const targetScroll = chatThread.scrollHeight - chatThread.offsetHeight;
            
            console.log('[Scroll] Message added, starting scroll animation');
            console.log(`[Scroll] Start position: ${startScroll}px`);
            console.log(`[Scroll] Target position: ${targetScroll}px`);
            
            // Ensure smooth scrolling is enabled
            chatThread.style.scrollBehavior = 'smooth';
            chatThread.scrollTop = targetScroll;
            
            // Log completion and reset scroll behavior
            setTimeout(() => {
                console.log(`[Scroll] Final position: ${chatThread.scrollTop}px`);
                console.log(`[Scroll] Scroll animation completed after ${Date.now() - startTime}ms`);
                chatThread.style.scrollBehavior = 'auto';
            }, 1000); // Wait for animation to complete
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            // Disable input while processing
            messageInput.disabled = true;
            sendButton.disabled = true;

            // Add user message to chat
            addMessage(message, true);
            messageInput.value = '';

            try {
                console.log('[0ms] Sending request...');
                const requestStart = Date.now();
                
                // Create a new buffer for this message
                const tokenBuffer = new TokenBuffer(20, 50);  // min 20 chars, max 50ms delay
                tokenBuffer.startNewMessage();

                // Make POST request with proper headers for streaming
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Accept': 'text/event-stream',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: message
                    })
                });

                console.log(`[${Date.now() - requestStart}ms] First byte received`);

                // Get the response as a readable stream
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                let buffer = '';
                let dataBuffer = ''; // Buffer specifically for data: prefix content
                let firstChunk = true;
                
                while (true) {
                    const {value, done} = await reader.read();
                    if (firstChunk && value) {
                        console.log(`[${Date.now() - requestStart}ms] First token received`);
                        firstChunk = false;
                    }
                    if (done) {
                        console.log(`[${Date.now() - requestStart}ms] Stream complete`);
                        // Try to process any remaining buffered content
                        if (dataBuffer) {
                            try {
                                const parsed = JSON.parse(dataBuffer);
                                if (parsed.content) {
                                    tokenBuffer.append(parsed.content);
                                }
                            } catch (e) {
                                console.warn('Failed to parse final buffer:', {
                                    dataBuffer,
                                    error: e.message
                                });
                            }
                        }
                        tokenBuffer.complete();
                        break;
                    }
                    
                    // Decode and add to buffer
                    buffer += decoder.decode(value, {stream: true});
                    
                    // Process complete lines
                    while (true) {
                        const newlineIndex = buffer.indexOf('\n');
                        if (newlineIndex === -1) break;
                        
                        const line = buffer.slice(0, newlineIndex);
                        buffer = buffer.slice(newlineIndex + 1);
                        
                        if (line.trim() === '') continue;
                        
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6); // Remove 'data: ' prefix
                            
                            if (data === '[DONE]') {
                                tokenBuffer.complete();
                                continue;
                            }
                            
                            // Add to data buffer and try to parse
                            dataBuffer += data;
                            try {
                                const parsed = JSON.parse(dataBuffer);
                                if (parsed.content) {
                                    tokenBuffer.append(parsed.content);
                                    dataBuffer = ''; // Clear buffer after successful parse
                                }
                            } catch (e) {
                                // Only log if it's not just an incomplete JSON object
                                if (!e.message.includes('Unexpected end of JSON input')) {
                                    console.warn('Parse attempt failed:', {
                                        data,
                                        dataBuffer,
                                        error: e.message
                                    });
                                }
                                // Keep accumulating data if it might be incomplete
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                addMessage('Sorry, there was an error processing your request.', false);
            } finally {
                // Re-enable input
                messageInput.disabled = false;
                sendButton.disabled = false;
                messageInput.focus();
            }
        }

        // Load chat history when page loads
        loadChatHistory();

        // Add event listener for Enter key
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Add clear chat functionality
        document.getElementById('clear-chat-button').addEventListener('click', async () => {
            try {
                // Clear the chat messages container immediately
                messagesContainer.innerHTML = '';
                
                // Create loading message with dots
                const tokenBuffer = new TokenBuffer(20, 50);
                tokenBuffer.startNewMessage();
                
                // Make the DELETE request
                const response = await fetch('/api/chat', {
                    method: 'DELETE'
                });

                const data = await response.json();
                
                if (response.ok) {
                    // Remove the loading message
                    messagesContainer.innerHTML = '';
                    
                    // Display the new welcome message
                    if (data.history && data.history.length > 0) {
                        data.history.forEach(msg => {
                            addMessage(msg.content, msg.role === 'user');
                        });
                    }
                } else {
                    console.error('Failed to clear chat:', data.error);
                    addMessage('Sorry, there was an error clearing the chat history. Please try again.', false);
                }
            } catch (error) {
                console.error('Error clearing chat:', error);
                addMessage('Sorry, there was an error clearing the chat history. Please try again.', false);
            }
        });
    </script>

</body>
</html>