<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Public Sans font import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Public+Sans:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- DEBUG INFO -->
    <!-- env={{dd_env}} -->
    <!-- version={{dd_version}} -->
    <!-- site={{dd_site}} -->
    <!-- token={{clientToken}} -->
    <!-- user_id={{user_id}} -->
    <!-- user_email={{user_email}} -->
    <!-- is_anonymous={{is_anonymous}} -->


<!-- See https://docs.datadoghq.com/logs/log_collection/javascript -->
<!--     https://docs.datadoghq.com/real_user_monitoring/browser  -->
<script 
    type="text/javascript" 
    src="https://www.datadoghq-browser-agent.com/datadog-logs-v4.js">
</script>

<script
    src="https://www.datadoghq-browser-agent.com/datadog-rum-v4.js"
    type="text/javascript">
</script>

<script>

        window.DD_LOGS &&
        DD_LOGS.init({
            site: '{{dd_site}}',
            clientToken: '{{clientToken}}',
            env: '{{dd_env}}',
            version: '{{dd_version}}',
            service: 'browser',
            forwardErrorsToLogs: true,
            sampleRate: 100,
            forwardConsoleLogs: 'all'
        })

        window.DD_RUM && window.DD_RUM.init({
            site: '{{dd_site}}',
            clientToken: '{{clientToken}}',
            env: '{{dd_env}}',
            version: '{{dd_version}}',
            service: 'browser',
            applicationId: '{{applicationId}}',
            sampleRate: 100,
            sessionReplaySampleRate: 100,
            trackInteractions: true,
            trackResources: true,
            trackLongTasks: true,
            defaultPrivacyLevel: 'mask-user-input',
            allowedTracingUrls: [ _ => { return true } ] // https://docs.datadoghq.com/real_user_monitoring/connect_rum_and_traces/?tab=browserrum
        });

        window.DD_RUM &&
        window.DD_RUM.startSessionReplayRecording() ;

        window.DD_LOGS && DD_LOGS.setGlobalContextProperty('team', "sandbox")

        window.DD_RUM && window.DD_RUM.setUser({ 
            id: '{{user_id}}', 
            email: '{{user_email}}', 
            anonymous: '{{is_anonymous}}'
        })
        // window.DD_RUM && window.DD_RUM.addRumGlobalContext('domain', '{{domain}}');

    </script>


    <meta charset="utf-8">
    <title>Chat Sandbox</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='home.css') }}" />

</head>

<body>
    <div class="user-info">
        <span class="user-id">{{user_id}}</span>
        <span class="user-email">{{user_email}}</span>
    </div>
    
    <div class="chat-thread">
        <div class="messages" id="chat-messages"></div>
    </div>
    
    <div class="chat-actions">
        <button id="clear-chat-button" class="clear-chat-btn">Clear Chat History</button>
    </div>

    <div class="message-input-container">
        <div class="message-input">
            <textarea 
                id="chat-input" 
                placeholder="Type your message here..."
                rows="1"
            ></textarea>
            <button id="send-button">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4.5 19.5L20 12L4.5 4.5L4.5 10.5L15 12L4.5 13.5L4.5 19.5Z" 
                          fill="currentColor" 
                          stroke="currentColor" 
                          stroke-width="1.5" 
                          stroke-linejoin="round"/>
            </svg> 
        </button>
        </div>
    </div>

    <script>
        class ChatUI {
            constructor() {
                this.thread = document.querySelector('.chat-thread');
                this.messagesContainer = document.getElementById('chat-messages');
                this.input = document.getElementById('chat-input');
                this.sendButton = document.getElementById('send-button');
                this.clearButton = document.getElementById('clear-chat-button');

                // Setup input auto-resize
                this.input.addEventListener('input', () => this.autoResizeInput());
            }

            autoResizeInput() {
                this.input.style.height = 'auto';
                const newHeight = Math.min(this.input.scrollHeight, 120);
                this.input.style.height = newHeight + 'px';
            }

            smoothScrollToBottom() {
                const startTime = Date.now();
                const startScroll = this.thread.scrollTop;
                const targetScroll = this.thread.scrollHeight - this.thread.offsetHeight;
                
                console.log('[Scroll] Starting scroll animation');
                console.log(`[Scroll] Start position: ${startScroll}px`);
                console.log(`[Scroll] Target position: ${targetScroll}px`);
                
                this.thread.style.scrollBehavior = 'smooth';
                this.thread.scrollTop = targetScroll;
                
                setTimeout(() => {
                    this.thread.style.scrollBehavior = 'auto';
                    console.log(`[Scroll] Final position: ${this.thread.scrollTop}px`);
                    console.log(`[Scroll] Animation completed after ${Date.now() - startTime}ms`);
                }, 300);
            }

            addMessage(content, isUser = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
                messageDiv.style.whiteSpace = 'pre-wrap';
                messageDiv.innerText = content;
                this.messagesContainer.appendChild(messageDiv);
                this.smoothScrollToBottom();
                return messageDiv;
            }

            showLoading() {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message assistant-message';
                messageDiv.style.whiteSpace = 'pre-wrap';
                
                const loadingDots = document.createElement('div');
                loadingDots.className = 'loading-dots';
                loadingDots.innerHTML = '<span></span><span></span><span></span>';
                
                messageDiv.appendChild(loadingDots);
                this.messagesContainer.appendChild(messageDiv);
                this.smoothScrollToBottom();
                return { messageDiv, loadingDots };
            }

            clearMessages() {
                this.messagesContainer.innerHTML = '';
            }

            setInputState(enabled) {
                this.input.disabled = !enabled;
                this.sendButton.disabled = !enabled;
                if (enabled) {
                    this.input.focus();
                }
            }
        }

        class TokenBuffer {
            constructor(minChunkSize, maxDelay, container, chatUI) {
                this.buffer = '';
                this.minChunkSize = minChunkSize;
                this.maxDelay = maxDelay;
                this.timeout = null;
                this.container = container.messageDiv;
                this.loadingDots = container.loadingDots;
                this.contentDiv = null;
                this.chatUI = chatUI;  // Store reference to ChatUI for scrolling
            }

            initializeContent() {
                if (!this.contentDiv) {
                    this.contentDiv = document.createElement('div');
                    this.contentDiv.className = 'message-content';
                    this.container.insertBefore(this.contentDiv, this.loadingDots);
                }
            }

            append(text) {
                this.initializeContent();
                this.buffer += text;
                
                if (this.buffer.length >= this.minChunkSize) {
                    this.flush();
                    return;
                }
                
                if (!this.timeout) {
                    this.timeout = setTimeout(() => this.flush(), this.maxDelay);
                }
            }

            flush() {
                if (this.buffer) {
                    const span = document.createElement('span');
                    span.textContent = this.buffer;
                    span.className = 'token';
                    this.contentDiv.appendChild(span);
                    this.buffer = '';
                    this.chatUI.smoothScrollToBottom();  // Scroll after adding new content
                }
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
            }

            clear() {
                this.buffer = '';
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
            }

            complete() {
                this.flush();
                if (this.loadingDots) {
                    this.loadingDots.remove();
                }
            }
        }

        class StreamProcessor {
            constructor(tokenBuffer) {
                this.tokenBuffer = tokenBuffer;
                this.reader = null;
                this.decoder = new TextDecoder();
                this.buffer = '';
                this.dataBuffer = '';
            }

            async processStream(response) {
                this.reader = response.body.getReader();
                
                try {
                    while (true) {
                        const {value, done} = await this.reader.read();
                        if (done) {
                            await this.handleStreamEnd();
                            break;
                        }
                        await this.processChunk(value);
                    }
                } catch (error) {
                    throw error; // Propagate error to caller
                }
            }

            async handleStreamEnd() {
                // Handle any remaining data when stream ends
                if (this.dataBuffer) {
                    try {
                        const parsed = JSON.parse(this.dataBuffer);
                        if (parsed.content) {
                            this.tokenBuffer.append(parsed.content);
                        }
                    } catch (e) {
                        console.warn('Failed to parse final buffer:', e);
                    }
                }
                this.tokenBuffer.complete();
            }

            async processChunk(value) {
                // Decode incoming chunks and add to buffer
                this.buffer += this.decoder.decode(value, {stream: true});
                
                // Process complete lines from buffer
                while (true) {
                    const newlineIndex = this.buffer.indexOf('\n');
                    if (newlineIndex === -1) break;  // No complete line yet
                    
                    // Extract and process one line
                    const line = this.buffer.slice(0, newlineIndex);
                    this.buffer = this.buffer.slice(newlineIndex + 1);
                    
                    await this.processLine(line);
                }
            }

            async processLine(line) {
                if (line.trim() === '') return;  // Skip empty lines
                
                // Handle SSE data events
                if (line.startsWith('data: ')) {
                    const data = line.slice(6);
                    
                    // Skip completion marker
                    if (data === '[DONE]') return;
                    
                    // Accumulate and parse JSON data
                    this.dataBuffer += data;
                    try {
                        const parsed = JSON.parse(this.dataBuffer);
                        if (parsed.content) {
                            this.tokenBuffer.append(parsed.content);
                            this.dataBuffer = '';  // Reset buffer after successful parse
                        }
                    } catch (e) {
                        // Ignore expected JSON parsing errors for incomplete chunks
                        if (!e.message.includes('Unexpected end of JSON input')) {
                            console.warn('Parse attempt failed:', e);
                        }
                    }
                }
            }
        }

        class ChatManager {
            constructor() {
                this.ui = new ChatUI();
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.ui.sendButton.addEventListener('click', () => this.sendMessage());
                this.ui.clearButton.addEventListener('click', () => this.clearHistory());
                this.ui.input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            }

            async loadHistory() {
                this.ui.setInputState(false);
                const loadingDiv = this.ui.showLoading();

                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ initial_load: true })
                    });

                    const data = await response.json();
                    this.ui.clearMessages();
                    
                    if (data.history && data.history.length > 0) {
                        data.history.forEach(msg => {
                            this.ui.addMessage(msg.content, msg.role === 'user');
                        });
                    }
                } catch (error) {
                    console.error('Error loading chat history:', error);
                    this.ui.clearMessages();
                    this.ui.addMessage('Hello! How can I help you today?', false);
                } finally {
                    this.ui.setInputState(true);
                }
            }

            async sendMessage() {
                // Get and validate message content
                const message = this.ui.input.value.trim();
                if (!message) return;

                // Disable input controls and clear the input
                this.ui.setInputState(false);
                this.ui.addMessage(message, true);
                this.ui.input.value = '';

                // Create loading state and initialize token buffer for streaming
                const container = this.ui.showLoading();
                const tokenBuffer = new TokenBuffer(20, 50, container, this.ui);
                const streamProcessor = new StreamProcessor(tokenBuffer);

                try {
                    // Make streaming request to chat API
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: {
                            'Accept': 'text/event-stream',  // Enable server-sent events
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ prompt: message })
                    });

                    // Process the stream
                    await streamProcessor.processStream(response);
                } catch (error) {
                    // Handle any errors during the streaming process
                    console.error('Error:', error);
                    container.loadingDots.remove();
                    this.ui.addMessage('Sorry, there was an error processing your request.', false);
                } finally {
                    // Re-enable input controls
                    this.ui.setInputState(true);
                }
            }

            async clearHistory() {
                this.ui.setInputState(false);
                this.ui.clearMessages();
                const loadingDiv = this.ui.showLoading();

                try {
                    const response = await fetch('/api/chat', { method: 'DELETE' });
                    const data = await response.json();
                    
                    this.ui.clearMessages();
                    
                    if (response.ok && data.history && data.history.length > 0) {
                        data.history.forEach(msg => {
                            this.ui.addMessage(msg.content, msg.role === 'user');
                        });
                    } else {
                        throw new Error(data.error || 'Failed to clear chat');
                    }
                } catch (error) {
                    console.error('Error clearing chat:', error);
                    this.ui.addMessage('Sorry, there was an error clearing the chat history. Please try again.', false);
                } finally {
                    this.ui.setInputState(true);
                }
            }
        }

        // Initialize and start the chat
        const chatManager = new ChatManager();
        chatManager.loadHistory();
    </script>

</body>
</html>